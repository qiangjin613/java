# 函数式编程
> Java 8 Lambda 表达式和方法引用 (Method References) 允许你以函数式编程。

### 历史
1. 计算机早期，内存稀缺又昂贵，都用**汇编语言**（虽然知道编译器，但编译器生成的代码很低效，比手工编码的汇编程序多很多字节，仅仅想到这一点，人们还是选择汇编语言）。通常使用自修改代码（通过修改内存中的代码来使程序执行不同的操作）的技术维护汇编代码，让程序运行。
2. 随着内存和处理器变得更便宜、更快。**C 语言**出现并被大多数汇编程序员认为更“高级”。同时，使用 C 创建自修改代码仍然不难。
3. 随着硬件越来越便宜，程序的规模和复杂性都在增长。让程序工作变得困难。一群程序员想方设法使代码更加一致和易懂。

使用纯粹的自修改代码造成的结果就是：我们很难确定程序在做什么。它也难以测试：除非你想一点点测试输出，代码转换和修改等等过程？

使用代码以某种方式操纵其他代码的想法也就冒了出来（只要能保证它更安全）。

从代码创建，维护和可靠性的角度来看，这个想法非常吸引人：我们不用从头开始编写大量代码，而是从易于理解、充分测试及可靠的现有小块开始，最后将它们组合在一起以创建新代码。

**函数式编程**（FP）应运而生，通过合并现有代码来生成新功能而不是从头开始编写所有内容，我们可以更快地获得更可靠的代码。（至少在某些情况下，这套理论似乎很有用）

#### OO、FP
可以这样理解：**OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。**

纯粹的函数式语言在安全性方面更进一步。它强加了额外的约束，即所有数据必须是不可变的：设置一次，永不改变。将值传递给函数，该函数然后生成新值但从不修改自身外部的任何东西（包括其参数或该函数范围之外的元素）。当强制执行此操作时，你知道任何错误都不是由所谓的副作用引起的，因为该函数仅创建并返回结果，而不是其他任何错误。（有效避免了并发的错误）

更好的是，“不可变对象和无副作用”范式解决了并发编程中最基本和最棘手的问题之一：可变共享状态的问题。这意味着代码的不同部分（在不同的处理器上运行）可以尝试同时修改同一块内存。*如果函数永远不会修改现有值但只生成新值，则不会对内存产生争用*，这是纯函数式语言的定义。 因此，经常提出纯函数式语言作为并行编程的解决方案（还有其他可行的解决方案）。



### 新旧对比
详看代码



### Lambda表达式
> Lambda 表达式是使用最小可能语法编写的函数定义。

说明：
1. Lambda 表达式产生函数，而不是类。（虽然在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是类，但是幕后有各种操作执行让 Lambda 看起来像函数）；
2. Lambda 语法尽可能少。


### 方法引用
> Java 8 方法引用没有历史包袱。方法引用组成：类名或对象名::方法名称

普通的方法引用需要方法签名的一致；而使用未绑定的引用时，函数式方法的签名（接口中的单个方法）不再与方法引用的签名完全匹配。



### 函数式接口









