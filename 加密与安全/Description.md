## 编码算法
最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。比如 UTF-8 编码，它是一种不定长编码，但可以从给定字符的 Unicode 编码推算出来。

### URL 编码
URL 编码是什么？
为什么需要 URL 编码？之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办。
URL编码的目的是把任意文本数据编码为%前缀表示的文本，编码后的文本仅包含A~Z，a~z，0~9，-，_，.，*和%，便于浏览器和服务器处理。

URL 编码规则：
- 如果字符是 A~Z，a~z，0~9 以及 -、_、.、*，则保持不变；
- 如果是其他字符，先转换为 UTF-8 编码，然后对每个字节以 %XX 表示。

### Base64 编码
描述：Base64编码是对二进制数据进行编码，表示成文本格式。
作用：Base64编码可以把任意长度的二进制数据变为纯文本，且只包含 A~Z、a~z、0~9、+、/、= 这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。
因为6位整数的范围总是0~63，所以，能用64个字符表示：字符A~Z对应索引0~25，字符a~z对应索引26~51，字符0~9对应索引52~61，最后两个索引62、63分别用字符+和/表示。
在Java中，二进制数据就是byte[]数组。
Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。
**Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1/3。**
如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。


## 哈希算法
哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个**固定长度**的输出摘要。

哈希算法最重要的特点就是：1）相同的输入一定得到相同的输出；2）不同的输入大概率得到不同的输出。

哈希算法的目的就是**为了验证原始数据是否被篡改。**

如：Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。两个相同的字符串永远会计算出相同的hashCode，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当我们自定义一个class时，覆写equals()方法时我们必须正确覆写hashCode()方法。

**哈希碰撞**是指：两个不同的输入得到了相同的输出，如：`"AaAaAa".hashCode();` 和 `"BBAaBB".hashCode();` 得到相同的 hashCode 值。
碰撞是一定会出现的！因为输出的字节长度是固定的，范围是固定的，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。

碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：1）碰撞概率低；2）不能猜测输出（没有规律）。
不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。

常用的哈希算法有：
[算法]    [输出长度（位）]   [输出长度（字节）]
MD5         128 bits        16 bytes
SHA-1       160 bits        20 bytes
RipeMD-160	160 bits	    20 bytes
SHA-256     256 bits	    32 bytes
SHA-512     512 bits	    64 bytes

根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。*MD5 因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。*
> 可以通过 Java Docs API： MessageDigest 类查看支持的所有 Hash 算法。

### 抵御彩虹表攻击
使用哈希口令时，还要注意防止彩虹表攻击。
因为如果拿到 MD5 密文，从 MD5 反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表，就可以通过查找获取明文口令。这也就是不要使用常用密码、生日、手机号作为密码的原因。

即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）（同理：要验证输出的哈希，必须同时提供这个额外添加的“随机数”。）。加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。

### 第三方工具类 BouncyCastle
Java标准库提供了一系列常用的哈希算法。但如果我们要用的某种算法，Java标准库没有提供怎么办？（自己写或者找一个现成的第三方库）
BouncyCastle（轻量级密码术包）是一个开源的第三方算法提供商，提供了大量的密码术算法。

Java 标准库的 java.security.Security 提供了一种标准机制，允许第三方提供商无缝接入。只需要 `Security.addProvider(new BouncyCastleProvider());` 将算法供应者添加到 Security 中，就可以直接使用 MessageDigest 进行操作，方便至极。
> 官网下载链接 https://www.bouncycastle.org/latest_releases.html


### Hmac算法
在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得相同的输入有所变化。这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。

Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。
Hmac算法总是和某种哈希算法配合起来用的。例如，Hmac 与 MD5 结合，对应的就是 HmacMD5 算法，它相当于“加盐”的 MD5。

问：为什么不使用 自己的随机数的Key，而是使用 Hmac算法 生成认证码呢？
因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：
1. HmacMD5使用的key长度是64字节，更安全；
2. Hmac是标准算法，同样适用于SHA-1等其他哈希算法；
3. Hmac输出和原有的哈希算法长度一致。

可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。

Hmac算法是一种标准的**基于密钥的哈希算法**，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。



## 对称加密算法
对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。




## 口令加密算法
用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。
PBE（Password Based Encryption）的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密。


## 密钥交换算法
DH（Diffie-Hellman）算法

