## 编码算法
最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。比如 UTF-8 编码，它是一种不定长编码，但可以从给定字符的 Unicode 编码推算出来。

### URL 编码

因为很多服务器只识别 ASCII 编码的字符，如果 URL 中包含中文等非 ASCII 字符就会产生乱码。出于兼容性考虑，就需要将编码转换为统一的格式再进行传输。

#### URL 编码规则

- 以下字符保持不变：`[A, Z]`、`[a, z]`、`[0, 9]`、`-`、`_`、`.`、`*`；
- 其他字符先转换为 UTF-8 编码，然后对每个字节以 `%XX` 表示。如：”中“在 UTF-8 编码中 16 进制展示为 `0xe4b8ad`，编码后 `%E4%B8%AD` （URL 编码转换的结果总是大写）。

编码后的字符序列只包含 `[A, Z]`、`[a, z]`、`[0, 9]`、`-`、`_`、`.`、`*`、`%`。

### Base64 编码

Base64 编码的目的是把二进制数据变成文本格式的数据，这样在很多文本中就可以处理二进制数据。如：电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用 Base64 对二进制文件进行编码，然后以文本的形式传送。

#### Base64 编码规则

1. 把 3 byte（= 24 bit） 的二进制数据按 6 bit 一组，划分为 4 组，用 4 个 int 整数分别表示这 4 组数据；
2. 然后查表，把 int 整数用索引对应到字符，得到编码后的字符串。

因为 6 bit 组成的整数的范围总是 [0, 63]，所以，能用 64 个字符表示：

- 字符 [A, Z] 对应索引 [0, 25]；
- 字符 [a, z] 对应索引 [26, 51]；
- 字符 [0, 9] 对应索引 [52, 61]；
- 最后两个索引 62、63 分别用字符 `+`、`/` 表示。

Base64 编码可以把**任意长度**的二进制数据变为纯文本，且只包含 `A`~`Z`、`a`~`z`、`0`~`9`、`+`、`/`、`=` 这些字符。

因为将 3 byte 的数据经过 Base64 编码后得到 4 byte 数据，所以说，它把原始数据的长度增加了 1/3。如果把 Base64 的 64 个字符编码表换成 32、48 或 58 个，就可以使用 Base32、Base48 和 Base58 编码。字符越少，编码的效率就会越低。

提问：如果要编码的数据不是 3 的倍数该怎么办？针对这种情况，需要在末尾补充零（即 `Ox00`），使其成为 3 的倍数再进行编码。编码后，在结尾加几个 `=` 表示补充了几个 `0x00`，解码的时候，去掉末尾补充的一个或两个 `0x00` 即可。

*这个补充的 0 不会和字符 A 冲突吗？疑惑ing ...*

#### 针对 URL 的 Base64 编码

因为标准的 Base64 编码会出现 `+`、`/` 和 `=`，所以不适合把 Base64 编码后的字符串放到 URL 中。在针对 URL 的 Base64 编码中，把 `+` 变成 `-`、`/` 变成 `_`。


## 哈希算法
哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个**固定长度**的输出摘要。

哈希算法最重要的特点就是：1）相同的输入一定得到相同的输出；2）不同的输入大概率得到不同的输出。

哈希算法的目的就是**为了验证原始数据是否被篡改。**

如：Java字符串的hashCode()就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节int整数。两个相同的字符串永远会计算出相同的hashCode，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当我们自定义一个class时，覆写equals()方法时我们必须正确覆写hashCode()方法。

**哈希碰撞**是指：两个不同的输入得到了相同的输出，如：`"AaAaAa".hashCode();` 和 `"BBAaBB".hashCode();` 得到相同的 hashCode 值。
碰撞是一定会出现的！因为输出的字节长度是固定的，范围是固定的，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。

碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：1）碰撞概率低；2）不能猜测输出（没有规律）。
不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。

常用的哈希算法有：
[算法]    [输出长度（位）]   [输出长度（字节）]
MD5         128 bits        16 bytes
SHA-1       160 bits        20 bytes
RipeMD-160	160 bits	    20 bytes
SHA-256     256 bits	    32 bytes
SHA-512     512 bits	    64 bytes

根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。*MD5 因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。*
> 可以通过 Java Docs API： MessageDigest 类查看支持的所有 Hash 算法。

### 抵御彩虹表攻击
使用哈希口令时，还要注意防止彩虹表攻击。
因为如果拿到 MD5 密文，从 MD5 反推明文口令，只能使用暴力穷举的方法。然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表，就可以通过查找获取明文口令。这也就是不要使用常用密码、生日、手机号作为密码的原因。

即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）（同理：要验证输出的哈希，必须同时提供这个额外添加的“随机数”。）。加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。

### 第三方工具类 BouncyCastle
Java标准库提供了一系列常用的哈希算法。但如果我们要用的某种算法，Java标准库没有提供怎么办？（自己写或者找一个现成的第三方库）
BouncyCastle（轻量级密码术包）是一个开源的第三方算法提供商，提供了大量的密码术算法。

Java 标准库的 java.security.Security 提供了一种标准机制，允许第三方提供商无缝接入。只需要 `Security.addProvider(new BouncyCastleProvider());` 将算法供应者添加到 Security 中，就可以直接使用 MessageDigest 进行操作，方便至极。
> 官网下载链接 https://www.bouncycastle.org/latest_releases.html


### Hmac算法
在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得相同的输入有所变化。这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。

Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。
Hmac算法总是和某种哈希算法配合起来用的。例如，Hmac 与 MD5 结合，对应的就是 HmacMD5 算法，它相当于“加盐”的 MD5。

问：为什么不使用 自己的随机数的Key，而是使用 Hmac算法 生成认证码呢？
因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：
1. HmacMD5使用的key长度是64字节，更安全；
2. Hmac是标准算法，同样适用于SHA-1等其他哈希算法；
3. Hmac输出和原有的哈希算法长度一致。

可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。

Hmac算法是一种标准的**基于密钥的哈希算法**，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同。



## 对称加密算法
对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。




## 口令加密算法
用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。
PBE（Password Based Encryption）的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密。


## 密钥交换算法
DH（Diffie-Hellman）算法

## 非对称加密算法
DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。

非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。
> 如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。

非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。

非对称加密 VS. 对称加密
- 显著优点：对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。
- 缺点：非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。

SO，在实际使用的时候，非对称加密总是和对称加密一起使用。通过非对称加密口令，然后使用对称加密进行通信。

可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。

## 签名算法
非对称加密中，经常使用通常是用公钥加密，私钥解密。

如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。
不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？
*这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如小明喜欢小红，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认小明喜欢小红这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。*

因此，*私钥加密得到的密文实际上就是数字签名*，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。

在实际应用中，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名。
对签名进行验证实际上就是用公钥解密，然后把解密后的哈希与原始消息的哈希进行对比。

因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。

常用数字签名算法有：
- MD5withRSA
- SHA1withRSA
- SHA256withRSA

实际上就是指定某种哈希算法进行RSA签名的方式。

如果使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。

除了用 RSA 签名外，还可以使用 DSA、ECDSA 签名算法进行签名。

DSA 只能配合 SHA 使用，如：
- SHA1withDSA
- SHA256withDSA
- SHA512withDSA

RSA 数字签名 VS. DSA 签名：DSA的优点是更快。

ECDSA签名：椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。

数字签名用于：1）防止伪造；2）防止抵赖；3）检测篡改。


## 数字证书

