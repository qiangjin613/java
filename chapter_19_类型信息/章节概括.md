类型信息讨论的是 Java 如何在运行时识别对象和类信息。主要有两种方式：
1. “传统的”RTTI：假设我们在编译时已经知道了所有的类型；
2. “反射”机制：允许我们在运行时发现和使用类的信息。


类型信息 --> 多态



### Class对象
要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为 **Class 对象** 的特殊对象完成的。

实际上，Class 对象就是用来创建该类所有 *常规* 对象的。Java 使用 Class 对象来实现 RTTI，即便是类型转换这样的操作都是用 Class 对象实现的。不仅如此，Class 类还提供了很多使用 RTTI 的其它方式。

> 类是程序的一部分，每个类都有一个 Class 对象

每当我们编写并且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。

想在运行时使用类型信息，就必须先得到 Clss 对象的引用。主要由两种方式：
1. Class.forName()：只需要知道类名即可；
2. 对象.getClass()：需要拥有目标类的对象；
3. 类字面常量获取类对象的引用。

通过 Class 创建类对象。主要有两种方式：
1. Class 对象.newInstance()：只能使用默认的无参构造器创建这个类的对象；
2. 反射的 API：

#### 类字面常量
类字面常量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段 TYPE。TYPE 字段是一个引用，指向对应的基本数据类型的 Class 对象。

如：`A.class;`。这样不仅更简单，而且更安全，因为它在编译期就会收到检查（因此不必放在 try 语句中）。并且它根除了 forName() 的调用，所以效率更高。（建议使用）

当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。

#### 泛化的 Class 引用
Class 引用总是指向某个 Class 对象，而 Class 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。它还包含该类的 static 成员，因此 Class 引用表明了它所指向对象的确切类型，而该对象便是 Class 类的一个对象。

Java 设计者看准机会，将它的类型变得更具体了一些。Java 引入泛型语法之后，我们可以使用泛型对 Class 引用所指向的 Class 对象的类型进行限定。

#### cast() 方法
Java 中用于 Class 引用的转型语法，cast() 在无法使用普通类型转换的情况下会显得非常有用（但事实却是这种情况非常少见）。Java 类库中另一个没有任何用处的特性就是 Class.asSubclass()，该方法允许你将一个 Class 对象转型为更加具体的类型。


### 类型转换检测


