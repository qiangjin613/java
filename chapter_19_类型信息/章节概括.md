类型信息讨论的是 Java 如何在运行时识别对象和类信息。主要有两种方式：
1. “传统的”RTTI：假设我们在编译时已经知道了所有的类型；
2. “反射”机制：允许我们在运行时发现和使用类的信息；（代表对象类型的 Class 对象）

关键字 instanceof：告诉我们对象是不是某个特定类型的实例。 （避免了 ClassCastException 异常）


类型信息 --> 多态



### Class对象
要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为 **Class 对象** 的特殊对象完成的。

实际上，Class 对象就是用来创建该类所有 *常规* 对象的。Java 使用 Class 对象来实现 RTTI，即便是类型转换这样的操作都是用 Class 对象实现的。不仅如此，Class 类还提供了很多使用 RTTI 的其它方式。

> 类是程序的一部分，每个类都有一个 Class 对象

每当我们编写并且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。

想在运行时使用类型信息，就必须先得到 Clss 对象的引用。主要由两种方式：
1. Class.forName()：只需要知道类名即可；
2. 对象.getClass()：需要拥有目标类的对象；
3. 类字面常量获取类对象的引用。

通过 Class 创建类对象。主要有两种方式：
1. Class 对象.newInstance()：只能使用默认的无参构造器创建这个类的对象；
2. 反射的 API：

#### 类字面常量
类字面常量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段 TYPE。TYPE 字段是一个引用，指向对应的基本数据类型的 Class 对象。

如：`A.class;`。这样不仅更简单，而且更安全，因为它在编译期就会收到检查（因此不必放在 try 语句中）。并且它根除了 forName() 的调用，所以效率更高。（建议使用）

当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。

#### 泛化的 Class 引用
Class 引用总是指向某个 Class 对象，而 Class 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。它还包含该类的 static 成员，因此 Class 引用表明了它所指向对象的确切类型，而该对象便是 Class 类的一个对象。

Java 设计者看准机会，将它的类型变得更具体了一些。Java 引入泛型语法之后，我们可以使用泛型对 Class 引用所指向的 Class 对象的类型进行限定。

#### cast() 方法
Java 中用于 Class 引用的转型语法，cast() 在无法使用普通类型转换的情况下会显得非常有用（但事实却是这种情况非常少见）。Java 类库中另一个没有任何用处的特性就是 Class.asSubclass()，该方法允许你将一个 Class 对象转型为更加具体的类型。


### 类型转换检测
【回顾】已知的 RTTI 类型包括：
1. “传统的”RTTI：由 RTTI 确保转换的正确性，如果执行错误的类型转换，就会发生 ClassCastException 异常；
2. “反射”机制：通过查询代表对象类型的 Class 对象可以获取运行时所需的信息。

RTTI 在 Java 中的第三种形式：使用关键字 instanceof。

判断有没有继承关系：
1. 对象1 instanceof 对象2：
2. Class对象.isInstance(Object obj)：
3. Class对象.isAssignableFrom(Class对象)：


### 注册工厂
使用工厂方法设计模式将对象的创建推迟到类本身。工厂方法可以以多态方式调用，并创建适当类型的对象。


### 类的等价比较
测试 Class 对象的相等性：
1. instanceof 的形式（instanceof和isInstance()）：产生的结果相同
2. == 和 equals()：产生的结果也相同。

但 instanceof 判断有没有派生关系，
而 == 和 equals() 与继承无关（要么是确定的类型，要么不是）


### 反射：运行时类型信息
在获得 Class 对象后，可以通过 getFields()、getMethods()、getConstructors() 等方法获取该对象的信息。

获得对象信息后可以使用 invoke() 方法调用与 Method 对象关联的方法。


### 动态代理
#### 代理
代理是基本的设计模式之一。
一个对象封装真实对象，代替其提供其他或不同的操作——这些操作通常涉及到与“真实”对象的通信，因此代理通常充当中间对象。
设计模式就是封装变更（所以必须改变一些东西以证明模式的合理行）。
如果希望将额外的操作与“真实对象”做分离时，代理可能会有所帮助，尤其是想要轻松地启用额外的操作时。
#### 动态代理
Java 的动态代理更进一步，不仅动态创建代理对象，而且动态处理对代理方法的调用。
在动态地理上进行的所有调用都被*重定向到单个调用处理程序*，该处理程序负责发现调用的内容并决定如何处理（最基本的是过滤该方法还是传递方法调用）。


### Optional类




### 接口和类型
1. 接口还是有耦合的
2. 可以通过反射调用那些非公共访问权限的方法
3. 可以通过反射获取、修改那些非公共访问权限的字段（在修改这一点上，对于 final 并没有效果...）

【总结】
通常，所有这些违反访问权限的操作并不是什么十恶不赦的。
首先说明，不应该去调用这些标志为 private 或包访问权限的方法。
如果有人使用反射调用了这写越权的方法，那么对他们（客户端程序员）来说，
如果你修改了这些方法的某些地方，他们不应该抱怨（因为这些本来就不是属于他们去使用的）。
另一方面，总在类中留下后门，也许会帮助你解决某些特定类型的问题（这些问题往往除此之外，别无它法）。
总之，不可否认，反射给我们带来了很多好处。

程序员往往对编程语言提供的访问控制过于自信，甚至认为 Java 在安全性上比其它提供了（明显）更宽松的访问控制的语言要优越。然而，正如你所看到的，事实并不是这样。


### 唠叨的小结
RTTI 允许通过匿名类的引用来获取类型信息。初学者极易误用它，因为在学会使用多态调用方法之前，这么做也很有效。有过程化编程背景的人很容易把程序组织成一系列 switch 语句，你可以用 RTTI 和 switch 实现功能，但这样就损失了多态机制在代码开发和维护过程中的重要价值。**面向对象编程语言是想让我们尽可能地使用多态机制，只在非用不可的时候才使用 RTTI。**

然而使用多态机制的方法调用，要求我们拥有基类定义的控制权。因为在你扩展程序的时候，可能会发现基类并未包含我们想要的方法。如果基类来自别人的库，这时 RTTI 便是一种解决之道：**可继承一个新类，然后添加你需要的方法。** 在代码的其它地方，可以检查你自己特定的类型，并调用你自己的方法。这样做不会破坏多态性以及程序的扩展能力，因为这样添加一个新的类并不需要修改程序中的 switch 语句。但如果想在程序中增加具有新特性的代码，你就必须使用 RTTI 来检查这个特定的类型。

我们已经看到，反射，因其更加动态的编程风格，为我们开创了编程的新世界。

但对有些人来说，反射的动态特性却是一种困扰。对那些已经习惯于静态类型检查的安全性的人来说，Java 中允许这种动态类型检查（只在运行时才能检查到，并以异常的形式上报检查结果）的操作似乎是一种错误的方向。有些人想得更远，他们认为引入运行时异常本身就是一种指示，指示我们应该避免这种代码。我发现这种意义的安全是一种错觉，因为总是有些事情是在运行时才发生并抛出异常的，即使是在那些不包含任何 try 语句块或异常声明的程序中也是如此。

因此，我认为一致性错误报告模型的存在使我们能够通过使用反射编写动态代码。当然，尽力编写能够进行静态检查的代码是有价值的（就是写通过编译这个环节就能识别出错误的代码），只要你有这样的能力。

但是我（《On Java 8》作者）相信动态代码是将 Java 与其它诸如 C++ 这样的语言区分开的重要工具之一。