类型信息讨论的是 Java 如何在运行时识别对象和类信息。主要有两种方式：
1. “传统的”RTTI：假设我们在编译时已经知道了所有的类型；
2. “反射”机制：允许我们在运行时发现和使用类的信息；（代表对象类型的 Class 对象）
3. 关键字 instanceof：告诉我们对象是不是某个特定类型的实例。 （避免了 ClassCastException 异常）


类型信息 --> 多态



### Class对象
要理解 RTTI 在 Java 中的工作原理，首先必须知道类型信息在运行时是如何表示的。这项工作是由称为 **Class 对象** 的特殊对象完成的。

实际上，Class 对象就是用来创建该类所有 *常规* 对象的。Java 使用 Class 对象来实现 RTTI，即便是类型转换这样的操作都是用 Class 对象实现的。不仅如此，Class 类还提供了很多使用 RTTI 的其它方式。

> 类是程序的一部分，每个类都有一个 Class 对象

每当我们编写并且编译了一个新类，就会产生一个 Class 对象（更恰当的说，是被保存在一个同名的 .class 文件中）。

想在运行时使用类型信息，就必须先得到 Clss 对象的引用。主要由两种方式：
1. Class.forName()：只需要知道类名即可；
2. 对象.getClass()：需要拥有目标类的对象；
3. 类字面常量获取类对象的引用。

通过 Class 创建类对象。主要有两种方式：
1. Class 对象.newInstance()：只能使用默认的无参构造器创建这个类的对象；
2. 反射的 API：

#### 类字面常量
类字面常量不仅可以应用于普通类，也可以应用于接口、数组以及基本数据类型。另外，对于基本数据类型的包装类，还有一个标准字段 TYPE。TYPE 字段是一个引用，指向对应的基本数据类型的 Class 对象。

如：`A.class;`。这样不仅更简单，而且更安全，因为它在编译期就会收到检查（因此不必放在 try 语句中）。并且它根除了 forName() 的调用，所以效率更高。（建议使用）

当使用 .class 来创建对 Class 对象的引用时，不会自动地初始化该 Class 对象。

#### 泛化的 Class 引用
Class 引用总是指向某个 Class 对象，而 Class 对象可以用于产生类的实例，并且包含可作用于这些实例的所有方法代码。它还包含该类的 static 成员，因此 Class 引用表明了它所指向对象的确切类型，而该对象便是 Class 类的一个对象。

Java 设计者看准机会，将它的类型变得更具体了一些。Java 引入泛型语法之后，我们可以使用泛型对 Class 引用所指向的 Class 对象的类型进行限定。

#### cast() 方法
Java 中用于 Class 引用的转型语法，cast() 在无法使用普通类型转换的情况下会显得非常有用（但事实却是这种情况非常少见）。Java 类库中另一个没有任何用处的特性就是 Class.asSubclass()，该方法允许你将一个 Class 对象转型为更加具体的类型。


### 类型转换检测
【回顾】已知的 RTTI 类型包括：
1. “传统的”RTTI：由 RTTI 确保转换的正确性，如果执行错误的类型转换，就会发生 ClassCastException 异常；
2. “反射”机制：通过查询代表对象类型的 Class 对象可以获取运行时所需的信息。

RTTI 在 Java 中的第三种形式：使用关键字 instanceof。

判断有没有继承关系：
1. 对象1 instanceof 对象2：
2. Class对象.isInstance(Object obj)：
3. Class对象.isAssignableFrom(Class对象)：


### 注册工厂
使用工厂方法设计模式将对象的创建推迟到类本身。工厂方法可以以多态方式调用，并创建适当类型的对象。


### 类的等价比较
测试 Class 对象的相等性：
1. instanceof 的形式（instanceof和isInstance()）：产生的结果相同
2. == 和 equals()：产生的结果也相同。

但 instanceof 判断有没有派生关系，
而 == 和 equals() 与继承无关（要么是确定的类型，要么不是）


### 反射：运行时类型信息
在获得 Class 对象后，可以通过 getFields()、getMethods()、getConstructors() 等方法获取该对象的信息。

获得对象信息后可以使用 invoke() 方法调用与 Method 对象关联的方法。


### 动态代理
#### 代理
代理是基本的设计模式之一。
一个对象封装真实对象，代替其提供其他或不同的操作——这些操作通常涉及到与“真实”对象的通信，因此代理通常充当中间对象。
设计模式就是封装变更（所以必须改变一些东西以证明模式的合理行）。
如果希望将额外的操作与“真实对象”做分离时，代理可能会有所帮助，尤其是想要轻松地启用额外的操作时。
#### 动态代理
Java 的动态代理更进一步，不仅动态创建代理对象，而且动态处理对代理方法的调用。
在动态地理上进行的所有调用都被*重定向到单个调用处理程序*，该处理程序负责发现调用的内容并决定如何处理（最基本的是过滤该方法还是传递方法调用）。


### Optional类




### 接口和类型


