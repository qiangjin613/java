# 7. 封装
> 由重构引出封装概念

一件好的作品都是经过反复打磨才变得优秀的。如果你把一段代码置于某个位置一段时间，过一会重新来看，你可能发现更好的实现方式。这是*重构（refactoring）* 的原动力之一，重构就是重写可工作的代码，使之更加可读，易懂，因而更易维护。

但是，在修改和完善代码的愿望下，也存在巨大的压力。通常，一些用户（客户端程序员（client programmers））希望你的代码在某些方面保持不变。所以你想修改代码，但他们希望代码保持不变。由此引出了面向对象设计中的一个基本问题：“如何区分变动的事物和不变的事物”。

这个问题对于类库（library）而言尤其重要。类库的使用者必须依赖他们所使用的那部分类库，并且知道如果使用了类库的新版本，不需要改写代码。另一方面，类库的开发者必须有修改和改进类库的自由，并保证客户代码不会受这些改动影响。

这可以通过约定解决。例如，类库开发者必须同意在修改类库中的一个类时，不会移除已有的方法，因为那样将会破坏客户端程序员的代码。与之相反的情况更加复杂。在有成员属性的情况下，类库开发者如何知道哪些属性被客户端程序员使用？这同样会发生在那些只为实现类库类而创建的方法上，它们也不是设计成可供客户端程序员调用的。如果类库开发者想删除旧的实现，添加新的实现，结果会怎样呢？任何这些成员的改动都可能破环客户端程序员的代码。因此类库开发者会被束缚，不能修改任何事物。

为了解决这一问题，Java 提供了*访问修饰符（access specifier）* 供类库开发者指明哪些对于客户端程序员是可用的，哪些是不可用的。

然而，类库组件的概念和对类库组件访问的控制仍然不完善。其中仍然存在问题就是如何将类库组件捆绑到一个内聚的类库单元中。Java 中通过 package 关键字加以控制。类在相同包下还是在不同包下，会影响访问修饰符。



### 7.1 包的概念
包内包含一组类，它们被组织在一个单独的命名空间（namespace）下。包也提供了一种管理命名空间的机制。所有类名之间都是相互隔离的。类 A 中的方法 f() 不会与类 B 中具有相同签名的方法 f() 冲突。

> 但是如果类名冲突呢？

为了解决冲突，我们为每个类创建一个唯一标识符组合。使用 package 将类进行组合。


> 为什么每个编译单元中只能有一个 public 类？

一个 Java 源代码文件称为一个编译单元（compilation unit）（有时也称翻译单元（translation unit））。每个编译单元的文件名后缀必须是 .java。在编译单元中可以有一个 public 类，它的类名必须与文件名相同（包括大小写，但不包括后缀名 .java）。每个编译单元中只能有一个 public 类，否则编译器不接受。如果这个编译单元中还有其他类（使用的应是默认访问修饰符），那么在包之外是无法访问到这些类的，因为它们不是 public 类，此时它们为主 public 类提供“支持”类（如果有多个 public 类，那么哪个类提供支持呢？）。

如果你使用了 package 语句，它必须是文件中除了注释之外的第一行代码。当这样的代码：
```java
package hiding;
```
意味着这个编译单元是一个名为 hiding 类库的一部分。换句话说，你正在声明的编译单元中的 public 类名称位于名为 hiding 的保护伞下。任何人想要使用该名称，必须指明完整的类名或者使用 import 关键字导入 hiding 。


#### 代码组织
当编译一个 .java 文件时， .java 文件的每个类都会有一个输出文件。每个输出的文件名和 .java 文件中每个类的类名相同，只是后缀名是 .class。因此，在编译少量的 .java 文件后，会得到大量的 .class 文件。

> 生成后的 .class 文件不会冲突吗？

不会。这是因为生成的 .class 文件也会跟 package 一样，被放到不同的目录下面。（利用操作系统的文件结构的层次性）

在 Java 中，可运行程序是一组 .class 文件，它们可以打包压缩成一个 Java 文档文件（JAR，使用 jar 文档生成器）。*Java 解释器负责查找、加载和解释这些文件。*


#### 创建独一无二的包名
一个包从未真正被打包成单一的文件，它可以由很多 .class 文件构成，因而事情就变得有点复杂了。为了避免这种情况，一种合乎逻辑的做法是将特定包下的所有 .class 文件都放在一个目录下。也就是说，利用操作系统的文件结构的层次性。这是 Java 解决混乱问题的一种方式。

将所有的文件放在一个子目录还解决了其他的两个问题：**创建独一无二的包名**和**查找可能隐藏于目录结构某处的类**。
> 创建独一无二的包名

按照惯例，package 名称是类的创建者的反顺序的 Internet 域名。如果你遵循惯例，因为 Internet 域名是独一无二的，所以你的 package 名称也应该是独一无二的，不会发生名称冲突。

> 查找可能隐藏于目录结构某处的类

此技巧的第二部分是把 package 名称分解成你机器上的一个目录，所以当 Java 解释器必须要加载一个 .class 文件时，它能定位到 .class 文件所在的位置。
1. 找出环境变量 CLASSPATH。CLASSPATH 包含一个或多个目录，用作查找 .class 文件的根目录。
2. 从根目录开始，Java 解释器获取包名并将每个句点替换成反斜杠，生成一个基于根目录的路径名。然后这个路径与 CLASSPATH 的不同项连接，解释器就在这些目录中查找与你所创建的类名称相关的 .class 文件（解释器还会查找某些涉及 Java 解释器所在位置的标准目录）。

注：CLASSPATH 可以包含多个不同的搜索路径，但在使用 JAR 文件时，必须清楚 JAR 文件的实际路径名称。如一个名为 grape.jar 的 JAR 文件，类路径应该包括：`C:\flavors\grape.jar`。一旦设置好类路径，该 JAR 包含的类可以运行在任意目录。


#### 冲突
> 如果通过 * 导入了两个包含相同名字类名的类库，会发生什么？

首先，只要你不写导致冲突的代码，就不会有问题；如果使用了有冲突的名字，必须明确指明全名。如：
```java
java.util.Vector v = new java.util.Vector();
```



### 7.2 访问修饰符
| 修饰符 | 允许访问的范围 |
| --- | ---|
| public | 无论在哪 |
| protected | 要在同一个包下，或者使用继承 |
| 默认 | 要在同一个包下 |
| private | 要在同一个类下 |

对于 protected 修饰符需要更加详细的说明，
如实例 B.class 中那样。
解释：https://blog.csdn.net/dawn_after_dark/article/details/74453915


#### protected
> protected 处理的是继承的概念

如果你创建了一个新包，并从另一个包继承类，那么唯一能访问的就是被继承类的 public 成员。（如果在同一个包中继承，就可以操作所有的包访问权限的成员。）



### 可用的位置
| 修饰符 | 可使用的位置 |
| --- | ---|
| 类 | public、默认（包访问权限） |
| 构造器/方法/成员变量 | public、protected、默认、private |

注：（使用时）先看类，再看构造器/方法/成员变量。



在一个具有包访问权限的类中定义一个 public 的构造器并不能真的使这个构造器成为 public，一个例子：
```java
package one;
class A {
	public A() {}
}
```
```java
package two;
public class B {
	public static void main(String[] args) {
		A a = new A();  // 报错：无法在 one 包外访问类 A
	} 
}
```


private 的一个例子：
```java
class S {
    // 通过 private 控制如何创建对象，防止同包的其他类直接访问这个构造器
    private S() {}
    // 创建 S 对象，必须调用 makeAS() 方法来创建对象
    static S makeAS() {
        return new S();
    }
}
```
不能因为类中某个对象的引用是 private，就认为其他对象也无法拥有该对象的 public 引用。
比如这里通过 makeAS() 访问到了 private S() 构造器，又比如通过 getter/setter 方法对 private 属性进行操作。 




### 7.3 接口和实现
访问控制通常被称为隐藏实现（implementation hiding）。将数据和方法包装进类中并把具体实现隐藏被称作是封装（encapsulation）。**封装的结果就是一个同时带有特征和行为的数据类型。**

> 出于两个重要的原因，访问控制在数据类型内部划定了边界。

第一个原因是确立客户端程序员可以使用和不能使用的边界。可以在结构中建立自己的内部机制而不必担心客户端程序员偶尔将内部实现作为他们可以使用的接口的一部分。

第一个原因是将接口与实现分离。如果在一组程序中使用接口，而客户端程序员只能向 public 接口发送消息的话，那么就可以自由地修改任何不是 public 的事物（例如包访问权限，protected，或 private 修饰的事物），却不会破坏客户端代码。



### 7.4 类访问权限
访问权限修饰符也可以用于确定类库中的哪些类对于类库的使用者是可用的。



### 7.5 小结
访问权限控制关注的是类库创建者和外部使用者之间的关系，这是一种交流方式。

实际中，并非皆是如此：当所有有东西都在一个包下，严格遵循访问控制权限也许不是最佳选择，默认访问权限也许就足够好了。






