import java.util.Random;
import java.util.SortedSet;
import java.util.TreeSet;

/*
【地位】集合优化了对象的存储，而流和对象的处理有关。

【定义】流是一系列与特定存储机制无关的元素——实际上，流并没有“存储”之说。

【作用】利用流，我们无需迭代集合中的元素，就可以提取和操作它们。
这些管道通常被组合在一起，在流上形成一条操作管道。

【流和集合】在大多数情况下，将对象存储在集合中是为了处理他们，
因此你将会发现你将把编程的主要焦点从集合转移到了流上。

【好处】流的一个核心好处是，它使得程序更加短小并且更易理解。
当 Lambda 表达式和方法引用（method references）和流一起使用的时候会让人感觉自成一体。
流使得 Java 8 更具吸引力。
 */
class Randoms {
    public static void main(String[] args) {
        new Random(47)
                .ints(5, 20)
                .distinct()
                .limit(7)
                .sorted()
                .forEach(System.out::println);
    }
}



/*
【命令式编程和声明式编程】
声明式编程（Declarative programming）是一种：声明要做什么，而非怎么做的编程风格。（如函数式编程）
命令式编程的形式更难以理解。（说白了也就是常规的面向过程的编程）
 */
class ImperativeRandoms {
    public static void main(String[] args) {
        Random rand = new Random(47);
        SortedSet<Integer> rints = new TreeSet<>();
        while (rints.size() < 7) {
            int r = rand.nextInt(20);
            if (r < 5) continue;
            rints.add(r);
        }
        System.out.println(rints);
    }
}
/*
在上述命令式编程的代码中，定义了 3 个变量： rand，rints 和 r。
由于 nextInt() 方法没有下限的原因（其内置的下限永远为 0），
所以我们要生成额外的值来过滤小于 5 的结果。

注意一点，在想要知道这段代码的真正意图，就要对代码进行研究。
而在声明式编程（Randoms.java）中，明确的声明了要做什么。
这种语义清晰性也是 Java 8 的流式编程更受推崇的重要原因。
 */


/*
【两个概念】
外部迭代：如 ImperativeRandoms.java 中显式编写迭代机制。
内部迭代：如 andoms.java 中流式编程采用内部迭代。

流式编程的核心特性之一。
这种机制使得编写的代码可读性更强，也更能利用多核处理器的优势。
通过放弃对迭代过程的控制，我们把控制权交给并行化机制。
（将在并发编程一章中进一步学习这部分内容）
 */

/*
另一个重要方面，流是懒加载的。这代表着它只在绝对必要时才计算。
可以将流看作“延迟列表”。
由于计算延迟，流能够表示非常大（甚至无限）的序列，而不需要考虑内存问题。
 */


/*
【流的引进】
（流这么好，那我们就要引进它）
但是，Java 设计者面临着这样一个难题：
Q：现存的大量类库不仅为 Java 所用，同时也被应用在整个 Java 生态圈数百万行的代码中。
如何将一个全新的流的概念融入到现有类库中呢？

A：在类中，可以添加更多的方法。只要不改变原有的方法，现有代码就不会受到干扰。
但是接口部分该怎么改造呢？（实现一个接口就要实现接口的所有方法）
特别是集合类的部分。
如果想把一个集合转换为流，
直接向接口添加新方法会破坏所有老的接口实现类（就要在老的接口的实现类中添加接口中新方法的具体实现）。

Java 8 采用的解决方案是：在接口中添加被 default（默认）修饰的方法。
通过这种方案，设计者们可以将流式（stream）方法平滑地嵌入到现有类中。
 */

/*
流方法预置的操作几乎已满足了我们平常所有的需求。
流操作的类型有三种：
1.创建流，
2.修改流元素（中间操作， Intermediate Operations），
3.消费流元素（终端操作， Terminal Operations）。最后一种类型通常意味着收集流元素（通常是到集合中）。
 */
