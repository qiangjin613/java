> thinking: 反射可以用来做什么？

反射可以在程序运行时发现并使用对象和的类的信息。

### 1. 为什么需要反射？

面向对象编程的一个基本目标是：多态，如下示例：

```java
List list = new ArrayList();
```

在后续的操作中，只需要操纵基类（List）即可。

但在一些场景下，需要确定泛化对象的具体类型，这时，反射就派上用场了。

```java
System.out.println(list.getClass().getName()); 
// output: java.util.ArrayList
```

### 2. Class 对象

> thinking: 类型信息在运行时是如何表示的？

Class 对象中记录了与类相关的信息，每一个类都有一个 Class 对象，Java 使用 Class 对象来执行反射。

> 如何获取 Class 对象？

可以使用以下方法获取 Class 对象：

- Class 的静态方法 java.lang.Class.forName()
- 类字面量（class literal），如：`ArrayList.class`

_Class.forName() vs. 类字面量_

- 类字面量更简单也更安全，因为他在编译器进行检查（所以不会抛出异常），另外还消除了对 forName() 方法的调用用，所以效率更高。
但在类不存在时，可以使用 Class.forName() 来在运行时加载这个类型信息，如：加载一个在编译时不存在的 Cat.Class，会报：Cat 类不存在。
- 仅使用 .class 来获取类对象时，不会导致初始化；而 Class.forName() 会立即初始化类以产生 Class 引用。

> Class 与 泛型

可以使用泛型语法来限制 Class 引用的类型。

> 类型转换检查

- 关键字 instanceof，限制：只能与命名类型进行比较，如：`list instanceof ArrayList`，也就是说，只有在编译时就知道的类型才能使用 instanceof。
- isInstance(Object obj)、isAssignableFrom(Class<?> cls) 验证对象类型

> 类型判断

- 关键字 instanceof、isInstance(Object obj) 与 isAssignableFrom(Class<?> cls) 的判断是等价的，都会判断父子（继承/实现）关系
- equals() 与 `==` 判断等价，只会判断是不是等于，不会判断父子关系

> Class 的常用方法

- getInterfaces()：获取 Class 本身使用的接口（不会使用父类中使用的接口）信息。
- newInstance()：使用 Class 中 public 的无参构造器创建一个对象 
（如果要使用非 public 的构造器创建对象，则需要先获取非 public 构造器（getDeclaredConstructors()），
再设置其权限（setAccessible(true)），然后创建对象（newInstance()）才行，这个操作需要 Constructor 的参与）。
- cast()、asSubclass() 类型转换，这种方式使用起来虽然没有强制类型转换，如：`(ArrayList) list` 这样简单方便，但在不能使用普通类型转换的情况下很有用。


> Java 中反射的应用

- 运行时获取类型信息
- 向下转型时的类型检查
- 关键字 instanceof

### 3. java.lang.reflect

> thinking: 当类在类在数据库中，在网络中获得时，如何使用不在程序空间中的这个类呢？

使用反射（Class 类 + java.lang.reflect 库）对这个“不存在”的类进行操作。

> Notice

没有任何方法（使用权限修饰符进行控制，使用内部类等进行控制）可以阻止反射进入并调用非公共访问权限的方法，对于字段也是如此。

不过，对于 final 字段，实际上是安全的，不会发生变化。（如：ModifyingPrivateFields.java 中那样）

