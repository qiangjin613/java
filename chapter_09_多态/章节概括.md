# 9.多态
> 多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。
> 多态也称动态绑定或后期绑定或运行时绑定。

多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加新特性时都可以“生长”的程序。

**封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节私有化把接口与实现分离。而多态是消除类型之间的耦合。**

继承允许把一个对象视为它本身的类型或它的基类类型，这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。多态方法调用允许一种类型表现出与相似类型的区别（同样的方法表现不同的行为），只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。



### 9.1 向上转型回顾
#### 不使用向上转型时
```java
class Stringed extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Stringed play()" + n);
    }
}
class Brass extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Brass play()" + n);
    }
}
class Music {
    public static void tune(Instrument i) {
        i.play(Note.MIDDLE_C);
    }
    public static void tune(Stringed i) {
        i.play(Note.MIDDLE_C);
    }
    public static void tune(Brass i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Instrument i = new Instrument();
        Stringed s = new Stringed();
        Brass b = new Brass();
        // 这里没有向上转型：
        tune(i); // output: Instrument2.play() MIDDLE_C
        tune(s); // output: Stringed play()MIDDLE_C
        tune(b); // output: Brass play()MIDDLE_C
    }
}
```
这样是可行的，但有一个主要的缺点：如果要新添一个 Instrument 的子类，就需要为每种类型都编写一个新的 tune() 方法。这意味着更多的编程，而且以后如果添加类似 tune() 的新方法或 Instrument 的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法，编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。


#### 使用向上转型
```java
class Stringed extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Stringed play()" + n);
    }
}
class Brass extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Brass play()" + n);
    }
}
class Music {
    public static void tune(Instrument i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Instrument i = new Instrument();
        Stringed s = new Stringed();
        Brass b = new Brass();
        // 向上转型为 Instrument：
        tune(i); // output: Instrument2.play() MIDDLE_C
        tune(s); // output: Stringed play()MIDDLE_C
        tune(b); // output: Brass play()MIDDLE_C
    }
}
```
当向上转型时，貌似忘记了对象的类型：在 tune() 中，没有什么子类型，有的是 Instrument 调用了 play()。

> 猜想：如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？




### 9.2 转机
在上述使用向上转型的代码中，tune() 的输出结果正式我们期望的，然而编译器是如何知道这里的 Instrument 引用指向的是 Wind，而不是 Brass 或 Stringed 呢？

编译器无法得知。为了深入理解这个问题，有必要研究一下绑定这个主题。

#### 方法调用绑定
> 将一个方法调用和一个方法主体关联起来称作绑定

根据”绑定“发生的时期，可分为：前期绑定、后期绑定。上述的困惑在于编译器只知道一个 Instrument 引用，它是怎么知道调用哪个方法呢？

解决办法就是**后期绑定**。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型（RTTI），从而调用恰当的方法。

Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。

#### 陷阱
1. “重写”私有方法：只有非 private 方法才能被重写
2. “重写”静态方法：是重写后的假象！
2. 属性和静态方法的多态性：只有普通的方法调用可以是多态的，

> 属性、静态方法（包括构造器）不具有多态性





### 9.3 构造器和多态




### 9.4 协变返回类型




### 9.5 使用继承设计







### 9.6 本章小结

