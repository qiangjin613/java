# 9.多态
> 多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。
> 多态也称动态绑定或后期绑定或运行时绑定。

多态提供了另一个维度的接口与实现分离，以解耦做什么和怎么做。多态不仅能改善代码的组织，提高代码的可读性，而且能创建有扩展性的程序——无论在最初创建项目时还是在添加新特性时都可以“生长”的程序。

**封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节私有化把接口与实现分离。而多态是消除类型之间的耦合。**

继承允许把一个对象视为它本身的类型或它的基类类型，这样就能把很多派生自一个基类的类型当作同一类型处理，因而一段代码就可以无差别地运行在所有不同的类型上了。多态方法调用允许一种类型表现出与相似类型的区别（同样的方法表现不同的行为），只要这些类型派生自一个基类。这种区别是当你通过基类调用时，由方法的不同行为表现出来的。



### 9.1 向上转型回顾
#### 不使用向上转型时
```java
class Stringed extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Stringed play()" + n);
    }
}
class Brass extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Brass play()" + n);
    }
}
class Music {
    public static void tune(Instrument i) {
        i.play(Note.MIDDLE_C);
    }
    public static void tune(Stringed i) {
        i.play(Note.MIDDLE_C);
    }
    public static void tune(Brass i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Instrument i = new Instrument();
        Stringed s = new Stringed();
        Brass b = new Brass();
        // 这里没有向上转型：
        tune(i); // output: Instrument2.play() MIDDLE_C
        tune(s); // output: Stringed play()MIDDLE_C
        tune(b); // output: Brass play()MIDDLE_C
    }
}
```
这样是可行的，但有一个主要的缺点：如果要新添一个 Instrument 的子类，就需要为每种类型都编写一个新的 tune() 方法。这意味着更多的编程，而且以后如果添加类似 tune() 的新方法或 Instrument 的新类型时，还有大量的工作要做。考虑到如果你忘记重载某个方法，编译器也不会提示你，这会造成类型的整个处理过程变得难以管理。


#### 使用向上转型
```java
class Stringed extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Stringed play()" + n);
    }
}
class Brass extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Brass play()" + n);
    }
}
class Music {
    public static void tune(Instrument i) {
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Instrument i = new Instrument();
        Stringed s = new Stringed();
        Brass b = new Brass();
        // 向上转型为 Instrument：
        tune(i); // output: Instrument2.play() MIDDLE_C
        tune(s); // output: Stringed play()MIDDLE_C
        tune(b); // output: Brass play()MIDDLE_C
    }
}
```
当向上转型时，貌似忘记了对象的类型：在 tune() 中，没有什么子类型，有的是 Instrument 调用了 play()。

> 猜想：如果只写一个方法以基类作为参数，而不用管是哪个具体派生类，这样会变得更好吗？也就是说，如果忘掉派生类，编写的代码只与基类打交道，会不会更好呢？




### 9.2 转机
在上述使用向上转型的代码中，tune() 的输出结果正式我们期望的，然而编译器是如何知道这里的 Instrument 引用指向的是 Wind，而不是 Brass 或 Stringed 呢？

编译器无法得知。为了深入理解这个问题，有必要研究一下绑定这个主题。

#### 方法调用绑定
> 将一个方法调用和一个方法主体关联起来称作绑定

根据”绑定“发生的时期，可分为：前期绑定、后期绑定。上述的困惑在于编译器只知道一个 Instrument 引用，它是怎么知道调用哪个方法呢？

解决办法就是**后期绑定**。当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型（RTTI），从而调用恰当的方法。

Java 中除了 static 和 final 方法（private 方法也是隐式的 final）外，其他所有方法都是后期绑定。

#### 陷阱
1. “重写”私有方法：只有非 private 方法才能被重写
2. “重写”静态方法：是重写后的假象！
2. 属性和静态方法的多态性：只有普通的方法调用可以是多态的，

> 属性、静态方法（包括构造器）不具有多态性





### 9.3 构造器和多态
> 尽管构造器不具有多态性（事实上人们会把它看作是隐式声明的静态方法），但是理解构造器在复杂层次结构中运作多态还是非常重要的。

#### 构造器调用顺序
在派生类的构造过程中总会调用基类的构造器。初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。

> 为什么初始化要按照继承层次结构上移呢？

当使用继承时，就已经知道了基类的一切，并可以访问基类中任意 public 和 protected 的成员。这意味着在派生类中可以假定所有的基类成员都是有效的。

在构造器中必须确保所有的成员都已经构建完。唯一能保证这点的方法就是首先调用基类的构造器（在派生类构造器的第一行调用）。接着，在派生类的构造器中，所有你可以访问的基类成员都已经初始化。

另一个在构造器中能知道所有成员都是有效的理由是：无论何时有可能的话，你应该在所有成员对象（通过组合将对象置于类中）定义处初始化它们（简单说就是“定义时初始化”）。如果遵循这条实践，就可以帮助确保所有的基类成员和当前对象的成员对象都已经初始化。

**不幸的是，这不能处理所有情况...比如：在构造器中使用多态**

> 为什么需要用构造器来完成构造对象的任务呢？（为什么编译器会强制调用基类构造器呢？）

*考虑属性，属性通常声明为 private，必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。因此，必须得调用所有构造器；否则就不能构造完整的对象。*

#### 继承和清理
在使用组合和继承创建新类时，大部分时候你无需关心清理。子对象通常会留给垃圾收集器处理。如果你存在清理问题，那么必须用心地为新类创建一个清理方法，解决方法可大致上分 2 种情况：
1. “对象拥有自己的成员对象，并且清楚知道它们能存活多久”的情况
2. “当某个成员对象被其他一个或多个对象共享的情况”

#### 构造器内部多态方法的行为
如果在构造器中使用了方法，要密切注意这个方法是否具有多态行为。

编写构造器有一条良好规范：
    做尽量少的事让对象进入良好状态。
    如果有可能的话，尽量不要调用类中的任何方法。
    **在基类的构造器中能安全调用的只有基类的 final 方法（这也适用于可被看作是 final 的 private 方法）。** 这些方法不能被重写，因此不会产生意想不到的结果。
    你可能无法永远遵循这条规范，但应该朝着它努力。




### 9.4 协变返回类型
详情看【part_04_协变返回类型】




### 9.5 使用继承设计
先看【part_05_使用继承设计】

#### 替代 vs 扩展
> 说的是“存粹的继承”，然后引出 RTTI 和向下转型

“存粹”的继承层次结构又称作 “is-a” 关系，指派生类只拥有基类的接口，派生类不会拥有除基类之外的其他接口（就是说没有自己的接口）。

存粹的替代意味着基类可以完美的替代派生类，当使用它们时，完全不需要知道这些子类的信息。也就是说，基类可以接收任意发送给派生类的消息，因为它们具有完全相同的接口。只需将派生类向上转型，不要关注对象的具体类型。所有一切都可以通过多态处理。

*使用这种方式思考，似乎纯粹的 ”is-a“ 关系是明智的做法。* 但是这也是一个陷阱，因为发现有继承并且扩展基类接口的方式（extend 似乎怂恿我们这么做）才是解决特定问题的完美方案。这可以称为“is - like - a” 关系（它有着相同的基本接口，但还具有额外方法的其他特性）。

在这个”完美方案“下，也存在缺点：派生类中接口的扩展部分在基类中不存在（不能通过基类访问到这些扩展接口），因此一旦向上转型，就不能通过基类调用这些新方法。

如果不向上转型，就不会遇到这个问题。但是通常情况下，我们需要重新查明对象的确切类型，从而能够访问该类型中的扩展方法。（就是说，知道使用了多态的基类对象的时候，想用子类扩展的那些方法，就要知道 RTTI 并且进行向下转型）

#### 向下转型与运行时类型信息
由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用向下转型。

向上转型永远是安全的，因为基类不会具有比派生类更多的接口。因此，每条发送给基类接口的消息都能被接收。但是对于向下转型，你无法知道一个形状是圆，它有可能是三角形、正方形或其他一些类型。

为了解决这个问题，必须得有某种方法确保向下转型是正确的，防止意外转型到一个错误类型，进而发送对象无法接收的消息。这么做是不安全的。（RTTI）

在某些语言中（如 C++），必须执行一个特殊的操作来获得安全的向下转型，但是在 Java 中，每次转型（包括向上和向下转型）都会被检查！所以即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型。如果不是，就会得到 ClassCastException （类转型异常）。

但是，为了访问派生对象的扩展接口，就要尝试向下转型！




### 9.6 本章小结
可以看到，如果不使用数据抽象和继承，就不可能理解甚至创建多态的例子。多态是一种不能单独看待的特性（比如像 switch 语句那样），它只能作为类关系全景中的一部分，与其他特性协同工作。

为了在程序中有效地使用多态乃至面向对象的技术，就必须扩展自己的编程视野，不能只看到单一类中的成员和消息，而要看到类之间的共同特性和它们之间的关系。尽管这需要很大的努力，但是这么做是值得的。它能带来更快的程序开发、更好的代码组织、扩展性更好的程序和更易维护的代码。

**但是记住，多态可能被滥用。仔细分析代码以确保多态确实能带来好处。**