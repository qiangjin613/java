#### 线程安全问题
多线程编程中很容易偶然出现线程安全问题，这时因为系统的线程调度有一定的随机性造成的。不过即使程序偶然出现问题，那也是由于编程不当造成的。
详情：ThreadSafetyProblem.java

#### 解决方案
为了解决线程安全的问题，Java 的多线程支持引入了**同步监视器**来解决这个问题。在线程开始执行**同步代码块、同步方法**之前，必须先获得对同步监视器的锁定，这样的做法也符合“加锁->修改->释放锁”的逻辑。
>任何线程在修改指定资源之前，首先对该资源进行加锁，在加锁期间，其他线程无法获得该资源，当该线程修改完成后，该线程释放对该资源的锁定。通过这种方式就可以保证并发线程在任何时刻只有一个线程可以进入修改共享资源的代码区（也称临界区、同步代码块），从而保证了线程的安全。

对于同步监视器的选择：虽然 Java 允许使用任何对象作为同步监视器，但同步监视器存在的目的是阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器。如果同步监视器选取不当，可能造成对同步代码块的锁定失效。

何时释放对同步监视器的锁定呢？
- 释放同步监视器的情况：
1）当前线程的同步方法、同步代码块执行结束；2）当前线程在执行同步方法、同步代码块中遇到 break、return 使代码正常中止；3）当前线程在执行同步方法、同步代码块中遇到未处理的 Error、Exception，导致程序被异常机制托管；4）当前线程在执行同步方法、同步代码块中遇到 wait 操作暂停当前线程的执行。
- 不会释放同步监视器的情况：
1）当前线程在执行同步方法、同步代码块中遇到 sleep、yield 操作暂停当前线程；2）当前线程执行同步代码块、同步方法时，其他线程调用了 suspend 操作将该线程挂起。
>可以看到，sleep、yield、suspend 操作都不会释放同步监视器锁，但是 suspend 需要显式调用 resume 操作后，该同步监视器的锁才可能会释放掉，所以尽量避免使用 suspend、resume 操作来控制线程，否则将增加发生死锁的可能性。

同步代码块 vs. 同步方法
- 同步代码块：显式指定同步监视器，操作空间大
- 同步方法：隐式指定 this 当前对象作为同步监视器，编码简单，不灵活
>synchronized 关键字可修饰方法、代码块(方法内的)，但不能修饰构造器、变量。


- 同步代码块 FirstSolution.java
- 同步方法 SecondSolution.java
- 同步锁 ThirdSolution.java
>如果看到这里，请联系 MySQL 的加锁实现原理思考，Java 对锁线程安全中，加锁锁的本质是什么？

#### 因为资源锁定带来的：死锁





### 相关补充
#### 可变类、不可变类 和 线程安全
不可变类总是线程安全的，因为它的状态不可被改变；但可变类需要额外的方法来保证其线程安全。
可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全带来的负面影响，程序经常采用如下策略：
1. 只对那些会改变竞争资源的方法进行同步；
2. 如果可变类有两种运行环境（单线程环境和多线程环境），则应该为可变类提供两种版本，即线程不安全的单线程版本保证性能，线程安全的多线程版本保护资源。
>JDK 提供的 StringBuilder、StringBuffer 就是一个例子。
