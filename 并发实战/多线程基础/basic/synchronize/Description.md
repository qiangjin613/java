#### 线程安全问题
多线程编程中很容易偶然出现线程安全问题，这时因为系统的线程调度有一定的随机性造成的。不过即使程序偶然出现问题，那也是由于编程不当造成的。
详情：ThreadSafetyProblem.java

#### 解决方案
- 同步代码块 FirstSolution.java
- 同步方法 SecondSolution.java
- 同步锁 ThirdSolution.java

为了解决线程安全的问题，Java 的多线程支持引入了**同步监视器**来解决这个问题。在线程开始执行**同步代码块、同步方法**之前，必须先获得对同步监视器的锁定，这样的做法也符合“加锁->修改->释放锁”的逻辑。
>任何线程在修改指定资源之前，首先对该资源进行加锁，在加锁期间，其他线程无法获得该资源，当该线程修改完成后，该线程释放对该资源的锁定。通过这种方式就可以保证并发线程在任何时刻只有一个线程可以进入修改共享资源的代码区（也称临界区、同步代码块），从而保证了线程的安全。

对于同步监视器的选择：虽然 Java 允许使用任何对象作为同步监视器，但同步监视器存在的目的是阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器。如果同步监视器选取不当，可能造成对同步代码块的锁定失效。

何时释放对同步监视器的锁定呢？
- 释放同步监视器的情况：
1）当前线程的同步方法、同步代码块执行结束；2）当前线程在执行同步方法、同步代码块中遇到 break、return 使代码正常中止；3）当前线程在执行同步方法、同步代码块中遇到未处理的 Error、Exception，导致程序被异常机制托管；4）当前线程在执行同步方法、同步代码块中遇到 wait 操作暂停当前线程的执行。
- 不会释放同步监视器的情况：
1）当前线程在执行同步方法、同步代码块中遇到 sleep、yield 操作暂停当前线程；2）当前线程执行同步代码块、同步方法时，其他线程调用了 suspend 操作将该线程挂起。
>可以看到，sleep、yield、suspend 操作都不会释放同步监视器锁，但是 suspend 需要显式调用 resume 操作后，该同步监视器的锁才可能会释放掉，所以尽量避免使用 suspend、resume 操作来控制线程，否则将增加发生死锁的可能性。

同步代码块 vs. 同步方法
- 同步代码块：显式指定同步监视器，操作空间大
- 同步方法：隐式指定 this 当前对象作为同步监视器，编码简单，不灵活
>synchronized 关键字可修饰方法、代码块(方法内的)，但不能修饰构造器、变量。

Java 5 的新选择：
Java 5 开始，Java 提供了一种功能更强大的线程同步机制，可通过显式定义同步锁对象（功能上等效于之前的同步监视器）来实现同步，在这种机制下，同步锁由 Lock 对象充当。Lock 提供了比 synchronized 方法/代码块更广泛的锁定操作，是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前必须先获得 Lock 对象（某些锁也允许对共享资源的并发访问）。

同步监视器 vs. 同步锁
- 同步监视器：
    多线程编程方便，避免了很多涉及锁的常见编程错误。
    缺点是：强制要求加锁和释放锁要出现在同一个块结构中，并且获取了多个锁时，必须以相反的顺序释放，且必须在与所有锁被获取时相同的范围内释放所有锁。
- 同步锁：
    使用锁的方式更为灵活，提供了同步监视器中没有的其他功能，包括：tryLock()、lockInterruptibly()、tryLock(long, TimeUnit) 等。
    缺点是：会出现一些设计锁的常见编程错误。


>如果看到这里，请联系 MySQL 的加锁实现原理思考，Java 对锁线程安全中，加锁锁的本质是什么？

#### 因为资源锁定带来的：死锁
当两个线程互相等待对方释放同步监视器时，就会发生死锁，Java 虚拟机没有检测，也没有采取措施来处理死锁情况，所以在多线程编程环节应采取措施避免死锁。
一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。
>死锁是很容易发生的，尤其在系统中出现多个同步监视器的情况下，如 DeadLock.java。


### 相关补充
#### 可变类、不可变类 和 线程安全
不可变类总是线程安全的，因为它的状态不可被改变；但可变类需要额外的方法来保证其线程安全。
可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全带来的负面影响，程序经常采用如下策略：
1. 只对那些会改变竞争资源的方法进行同步；
2. 如果可变类有两种运行环境（单线程环境和多线程环境），则应该为可变类提供两种版本，即线程不安全的单线程版本保证性能，线程安全的多线程版本保护资源。
>JDK 提供的 StringBuilder、StringBuffer 就是一个例子。
#### Java 中锁的介绍
1. Java 5 提供了 Lock、ReadWriteLock 两个根接口，并为 Lock 提供了 ReentrantLock（可重入锁）实现类，为 ReadWriteLock 提供了 ReentrantReadWriteLock（可重入读写锁）实现类。
2. Java 8 提供了新的 StampedLock 类，在大多数场景中，可以代替传统的 ReentrantReadWriteLock。




--- 待合并的总结
### synchronized 关键字
同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码。

说明：
- 使用 synchronized 的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对；
- 在使用 synchronized 的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁

#### 不需要同步的操作
JVM规范定义了几种原子操作：
- 基本类型（long和double除外）赋值，例如：int n = m；
- 引用类型赋值，例如：List<String> list = anotherList。

说明：
- 单条原子操作的语句是不需要同步的，比如：`this.i = i;`。但是，如果是多赋值，就不许要博正同步操作，如：`this.i = i; this.j = j;`
- long 和 double 是 64 位数据，JVM 没有明确规定 64 位赋值操作是不是一个原子操作，不过在 x64 平台的 JVM 是把 long 和 double 的赋值作为原子操作实现的。

有时，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如赋值多个变量的情况：
```java
class Pair {
    int[] pair;
    public void set(int i, int j) {
        int[] temp = new int[] { i, j };
        pair = temo;
    }
}
```
其中 set() 就不需要同步，因为 `pair = temo;` 是引用赋值的原子操作。而 `int[] temp = new int[] { i, j };` 是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。

#### 同步代码块
使用步骤：
1. 找出修改共享变量的线程代码块；
2. 选择一个共享实例作为锁；
3. 使用 synchronized (lockObject) { ... }。

#### 同步方法
当 Java 程序依靠 synchronized 对线程进行同步的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把 synchronized 逻辑封装起来。

以下两种实现等价：
```java
class Counter {
    public void add(int n) {
        synchronized(this) { // 锁住 this
            count += n;
        } // 解锁
    }
}
```
```java
class Counter {
    public synchronized void add(int n) { // 锁住 this
        count += n;
    } // 解锁
}
```

对于 static 方法，是没有 this 实例的，因为 static 方法是针对类而不是实例。但是我们注意到任何一个类都有一个由 JVM 自动创建的 Class 实例，因此，对 static 方法添加 synchronized，锁住的是该类的 Class 实例。如：
```java
class Counter {
    public static void add(int n) {
        synchronized(Counter.class) { // 锁住 Counter.class
            count += n;
        } // 解锁
    }
}
```






### 同步锁









### synchronized VS. 同步锁












