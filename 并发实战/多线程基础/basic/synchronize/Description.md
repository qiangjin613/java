#### 线程安全问题
多线程编程中很容易偶然出现线程安全问题，这时因为系统的线程调度有一定的随机性造成的。不过即使程序偶然出现问题，那也是由于编程不当造成的。
详情：ThreadSafetyProblem.java

#### 解决方案
- 同步代码块 FirstSolution.java
- 同步方法 SecondSolution.java
- 同步锁 ThirdSolution.java

为了解决线程安全的问题，Java 的多线程支持引入了**同步监视器**来解决这个问题。在线程开始执行**同步代码块、同步方法**之前，必须先获得对同步监视器的锁定，这样的做法也符合“加锁->修改->释放锁”的逻辑。
>任何线程在修改指定资源之前，首先对该资源进行加锁，在加锁期间，其他线程无法获得该资源，当该线程修改完成后，该线程释放对该资源的锁定。通过这种方式就可以保证并发线程在任何时刻只有一个线程可以进入修改共享资源的代码区（也称临界区、同步代码块），从而保证了线程的安全。

对于同步监视器的选择：虽然 Java 允许使用任何对象作为同步监视器，但同步监视器存在的目的是阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源充当同步监视器。如果同步监视器选取不当，可能造成对同步代码块的锁定失效。

何时释放对同步监视器的锁定呢？
- 释放同步监视器的情况：
1）当前线程的同步方法、同步代码块执行结束；2）当前线程在执行同步方法、同步代码块中遇到 break、return 使代码正常中止；3）当前线程在执行同步方法、同步代码块中遇到未处理的 Error、Exception，导致程序被异常机制托管；4）当前线程在执行同步方法、同步代码块中遇到 wait 操作暂停当前线程的执行。
- 不会释放同步监视器的情况：
1）当前线程在执行同步方法、同步代码块中遇到 sleep、yield 操作暂停当前线程；2）当前线程执行同步代码块、同步方法时，其他线程调用了 suspend 操作将该线程挂起。
>可以看到，sleep、yield、suspend 操作都不会释放同步监视器锁，但是 suspend 需要显式调用 resume 操作后，该同步监视器的锁才可能会释放掉，所以尽量避免使用 suspend、resume 操作来控制线程，否则将增加发生死锁的可能性。

同步代码块 vs. 同步方法
- 同步代码块：显式指定同步监视器，操作空间大
- 同步方法：隐式指定 this 当前对象作为同步监视器，编码简单，不灵活
>synchronized 关键字可修饰方法、代码块(方法内的)，但不能修饰构造器、变量。

Java 5 的新选择：
Java 5 开始，Java 提供了一种功能更强大的线程同步机制，可通过显式定义同步锁对象（功能上等效于之前的同步监视器）来实现同步，在这种机制下，同步锁由 Lock 对象充当。Lock 提供了比 synchronized 方法/代码块更广泛的锁定操作，是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前必须先获得 Lock 对象（某些锁也允许对共享资源的并发访问）。

同步监视器 vs. 同步锁
- 同步监视器：
    多线程编程方便，避免了很多涉及锁的常见编程错误。
    缺点是：强制要求加锁和释放锁要出现在同一个块结构中，并且获取了多个锁时，必须以相反的顺序释放，且必须在与所有锁被获取时相同的范围内释放所有锁。
- 同步锁：
    使用锁的方式更为灵活，提供了同步监视器中没有的其他功能，包括：tryLock()、lockInterruptibly()、tryLock(long, TimeUnit) 等。
    缺点是：会出现一些设计锁的常见编程错误。


>如果看到这里，请联系 MySQL 的加锁实现原理思考，Java 对锁线程安全中，加锁锁的本质是什么？

#### 因为资源锁定带来的：死锁
当两个线程互相等待对方释放同步监视器时，就会发生死锁，Java 虚拟机没有检测，也没有采取措施来处理死锁情况，所以在多线程编程环节应采取措施避免死锁。
一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程处于阻塞状态，无法继续。
>死锁是很容易发生的，尤其在系统中出现多个同步监视器的情况下，如 DeadLock.java。


### 相关补充
#### 可变类、不可变类 和 线程安全
不可变类总是线程安全的，因为它的状态不可被改变；但可变类需要额外的方法来保证其线程安全。
可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全带来的负面影响，程序经常采用如下策略：
1. 只对那些会改变竞争资源的方法进行同步；
2. 如果可变类有两种运行环境（单线程环境和多线程环境），则应该为可变类提供两种版本，即线程不安全的单线程版本保证性能，线程安全的多线程版本保护资源。
>JDK 提供的 StringBuilder、StringBuffer 就是一个例子。
#### Java 中锁的介绍
1. Java 5 提供了 Lock、ReadWriteLock 两个根接口，并为 Lock 提供了 ReentrantLock（可重入锁）实现类，为 ReadWriteLock 提供了 ReentrantReadWriteLock（可重入读写锁）实现类。
2. Java 8 提供了新的 StampedLock 类，在大多数场景中，可以代替传统的 ReentrantReadWriteLock。
