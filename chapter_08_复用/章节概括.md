# 8. 复用
> 代码复用是面向对象编程（OOP）最具魅力的原因之一。

对于像 C 语言等面向过程语言来说，“复用”通常指的就是“复制代码”。在面向对象编程的 Java，围绕“类”（Class）来解决问题。我们可以直接使用别人构建或调试过的代码，而非创建新类、重新开始。

在不污染源代码的前提下使用现存代码是需要技巧的。在这里提供两个方式来达到这个目的：
1. 组合（Composition）<br>
组合的方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”，通过这种方式*复用代码的功能，而非其形式*。
2. 继承（Inheritance）<br>
继承的方式更为微妙。创建现有类类型的新类。照字面理解：*采用现有类形式，又无需在编码时改动其代码*，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一。



### 8.1 组合
仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。

对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。惰性加载：（需要用到这个引用/对象时，再进行初始化，可减少编译器的负担）



### 8.2 继承
继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。

#### 初始化基类
因“继承”而产生的专有的两个名词：基类和派生类。

必须正确初始化基类子对象，而且只有一种方法可以保证这一点: 通过调用基类构造函数在构造函数中执行初始化，并且该构造函数具有执行基类初始化所需的所有适当信息和特权。（如果没有显式调用基类构造函数，Java 会自动在派生类构造函数中隐式调用基类构造函数）

#### 带参数的构造函数
编译器其实很笨，只会自动寻找、调用不带参数的构造器。如果该类中没有不带参数的构造器，则需要使用 super 指定使用的是基类（父类）的哪个构造器，否则编译器就会报错！



### 8.3 委托
> Java 不直接支持委托，但可以使用一种设计模式来实现

委托介于继承和组合之间：将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。




### 8.4 结合组合与继承

#### 保证适当的清理
> Java 没有 C++ 中析构函数的概念，析构函数是在对象被销毁时自动调用的方法

没有析构函数的原因可能是，在Java中，通常是忘掉而不是销毁对象，从而允许垃圾收集器根据需要回收内存（但有时在类中可能在其生命周期中执行一些需要清理的活动，比如关闭资源等活动）。因为无法知道垃圾收集器何时会被调用，甚至它是否会被调用。因此，如果你想为类清理一些东西，必须显式地编写一个特殊的方法来完成它，并确保客户端程序员知道他们必须调用这个方法。最重要的是（正如在"异常"章节中描述的）必须通过在 finally子句中放置此类清理来防止异常。

在清理方法中，必须注意基类和成员对象清理方法的顺序调用，以防止一个子对象依赖于另一个子对象。（如part_04_组合与继承.java 中的【保证适当的清理】示例：继承中 dispose() 编写方法和使用的时机）

> 虽然 Java 有垃圾回收，但不能依赖垃圾收集来做任何事情

在很多情况下，清理问题不是问题；你只需要让垃圾收集器来完成这项工作。但是，当你必须执行显式清理时，就需要多做努力，更加细心，因为在垃圾收集方面没有什么可以依赖的。*可能永远不会调用垃圾收集器。如果调用，它可以按照它想要的任何顺序回收对象。* 除了内存回收外，你不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用 finalize()。

#### 名称隐藏
如果 Java 基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。不管方法是在当前类中定义的，还是在基类中定义的，重载都会起作用。

在方法的调用上，如果有就调用准确匹配的方法，如果没有就进行向上转型找有没有相关方法。

经常与重载放在一起的是覆盖同名方法，在覆盖时，可使用 @Override 注解标注是覆盖而不是重载。@Override 注解保证了方法签名和返回值的一致性（是完全一致，这里没有协变返回类型的参与）

关于 @Override 的一些思考：
1. 会帮助检查是否正确的覆盖了父类中已有的方法
2. 很明白的告诉读代码的人，这个方法是个覆写的方法
3. 在没有访问权限的情况下覆盖方法的时候该注解会提示你“不可以这样做”，比如覆盖一个私有方法




### 8.5 组合与继承的选择
看 `part_05_组合与继承的选择.java` 更加易于理解。




### 8.6 protected
即然已经有了“继承”，关键字 protected 就变得有意义了。在理想世界中，仅靠关键字 private 就足够了。在实际项目中，却经常想把一个事物尽量对外界隐藏，而允许派生类的成员访问。关键字 protected 就起这个作用。它表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（包访问权限 + 继承它的子类）

尽管可以创建 protected 属性，但是最好的方式是将属性声明为 private 以一直保留更改底层实现的权利。然后通过 protected 控制类的继承者的访问权限。




### 8.7 向上转型
看 `part_07_向上转型.java` 更加易于理解。




### 8.8 final关键字





