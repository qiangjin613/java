# 8. 复用
> 代码复用是面向对象编程（OOP）最具魅力的原因之一。

对于像 C 语言等面向过程语言来说，“复用”通常指的就是“复制代码”。在面向对象编程的 Java，围绕“类”（Class）来解决问题。我们可以直接使用别人构建或调试过的代码，而非创建新类、重新开始。

在不污染源代码的前提下使用现存代码是需要技巧的。在这里提供两个方式来达到这个目的：
1. 组合（Composition）<br>
组合的方式直接了当。在新类中创建现有类的对象。这种方式叫做“组合”，通过这种方式*复用代码的功能，而非其形式*。
2. 继承（Inheritance）<br>
继承的方式更为微妙。创建现有类类型的新类。照字面理解：*采用现有类形式，又无需在编码时改动其代码*，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一。



### 8.1 组合
仅需要把对象的引用（object references）放置在一个新的类里，这就使用了组合。

对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。惰性加载：（需要用到这个引用/对象时，再进行初始化，可减少编译器的负担）



### 8.2 继承
继承是所有面向对象语言的一个组成部分。事实证明，在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承 Java 的标准根类对象（Object）。

#### 初始化基类
因“继承”而产生的专有的两个名词：基类和派生类。

必须正确初始化基类子对象，而且只有一种方法可以保证这一点: 通过调用基类构造函数在构造函数中执行初始化，并且该构造函数具有执行基类初始化所需的所有适当信息和特权。（如果没有显式调用基类构造函数，Java 会自动在派生类构造函数中隐式调用基类构造函数）

#### 带参数的构造函数
编译器其实很笨，只会自动寻找、调用不带参数的构造器。如果该类中没有不带参数的构造器，则需要使用 super 指定使用的是基类（父类）的哪个构造器，否则编译器就会报错！



### 8.3 委托
> Java 不直接支持委托，但可以使用一种设计模式来实现

委托介于继承和组合之间：将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。




### 8.4 结合组合与继承

#### 保证适当的清理
> Java 没有 C++ 中析构函数的概念，析构函数是在对象被销毁时自动调用的方法

没有析构函数的原因可能是，在Java中，通常是忘掉而不是销毁对象，从而允许垃圾收集器根据需要回收内存（但有时在类中可能在其生命周期中执行一些需要清理的活动，比如关闭资源等活动）。因为无法知道垃圾收集器何时会被调用，甚至它是否会被调用。因此，如果你想为类清理一些东西，必须显式地编写一个特殊的方法来完成它，并确保客户端程序员知道他们必须调用这个方法。最重要的是（正如在"异常"章节中描述的）必须通过在 finally子句中放置此类清理来防止异常。

在清理方法中，必须注意基类和成员对象清理方法的顺序调用，以防止一个子对象依赖于另一个子对象。（如part_04_组合与继承.java 中的【保证适当的清理】示例：继承中 dispose() 编写方法和使用的时机）

> 虽然 Java 有垃圾回收，但不能依赖垃圾收集来做任何事情

在很多情况下，清理问题不是问题；你只需要让垃圾收集器来完成这项工作。但是，当你必须执行显式清理时，就需要多做努力，更加细心，因为在垃圾收集方面没有什么可以依赖的。*可能永远不会调用垃圾收集器。如果调用，它可以按照它想要的任何顺序回收对象。* 除了内存回收外，你不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用 finalize()。

#### 名称隐藏
如果 Java 基类的方法名多次重载，则在派生类中重新定义该方法名不会隐藏任何基类版本。不管方法是在当前类中定义的，还是在基类中定义的，重载都会起作用。

在方法的调用上，如果有就调用准确匹配的方法，如果没有就进行向上转型找有没有相关方法。

经常与重载放在一起的是覆盖同名方法，在覆盖时，可使用 @Override 注解标注是覆盖而不是重载。@Override 注解保证了方法签名和返回值的一致性（是完全一致，这里没有协变返回类型的参与）

关于 @Override 的一些思考：
1. 会帮助检查是否正确的覆盖了父类中已有的方法
2. 很明白的告诉读代码的人，这个方法是个覆写的方法
3. 在没有访问权限的情况下覆盖方法的时候该注解会提示你“不可以这样做”，比如覆盖一个私有方法




### 8.5 组合与继承的选择
看 `part_05_组合与继承的选择.java` 更加易于理解。




### 8.6 protected
即然已经有了“继承”，关键字 protected 就变得有意义了。在理想世界中，仅靠关键字 private 就足够了。在实际项目中，却经常想把一个事物尽量对外界隐藏，而允许派生类的成员访问。关键字 protected 就起这个作用。它表示“就类的用户而言，这是 private 的。但对于任何继承它的子类或在同一包中的类，它是可访问的。”（包访问权限 + 继承它的子类）

尽管可以创建 protected 属性，但是最好的方式是将属性声明为 private 以一直保留更改底层实现的权利。然后通过 protected 控制类的继承者的访问权限。




### 8.7 向上转型
看 `part_07_向上转型.java` 更加易于理解。




### 8.8 final关键字
根据上下文环境，Java 的关键字 final 的含义有些微的不同，但通常它指的是“这是不能被改变的”。防止改变有两个原因：设计或效率。因为这两个原因相差很远，所以有可能误用关键字 final。

可能使用 final 的 3 个地方：
1. final 数据（包含变量、参数）
2. final 方法
3. final 类


#### final数据
许多编程语言都有某种方法告诉编译器有一块数据是恒定不变的。恒定有用的，如：
1. 一个永不改变的编译时常量
2. 一个在运行时初始化就不会改变的值

##### final修饰变量的情况
> 什么是编译时常量？

对于编译时常量这种情况，编译器可以把常量带入计算中；也就是说，可以在编译时计算（在编译时就知道它的值），从而减少了一些运行时的负担。<br>
在 Java 中，这类常量必须是基本类型、必须在定义常量的时候进行赋值，而且用关键字 final 修饰。<br>
按照惯例，编译时常量命名全部使用大写，单词之间用下划线分隔。（源于 C 语言的风格）<br>
（有一点，不能因为某数据被 final 修饰就认为在编译时就可以知道它的值，要是编译时常量才行！）

一个同时被 static final 修饰的属性只会占用一段不能改变的存储空间。

对于 `private static final int one = 47;` 是一种比较典型的常量定义方式：private 是私有变量；static final int 类变量并且还是一个编译时常量。


> 当用 final 修饰对象引用而非基本类型时，其含义会有一点令人困惑。

对于基本类型，final 使数值恒定不变，而对于对象引用，final 使引用恒定不变。一旦引用被初始化指向了某个对象，它就不能改为指向其他对象。但是，对象本身是可以修改的，Java 没有提供将任意对象设为常量的方法。（可以通过编写恒定类，达到 final 修饰引用的不变效果）


> 什么是空白 final？

空白 final 指没有初始化值的 final 属性。

有一个问题：对于编译器而言，编译器要确保 final 在使用前必须被初始化。那 final 的属性值在哪里初始化呢？<br>
回答是：在 构造器 或 初始化块 中。

这样做的好处是“既能使一个类的每个对象的 final 属性值不同，也能保持它的不变性”。

##### final修饰参数的情况
在参数列表中，将参数声明为 final 意味着在方法中不能改变参数指向的对象或基本变量（参数为引用时，也可以改变参数的引用属性值，这一点上是相同的）。只能读取而不能修改参数。这个特性主要用于传递数据给匿名内部类。


#### final方法
使用 final 方法的原因有两个：
1. 给方法上锁 <br>
防止子类通过覆写方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。
2. 效率 <br>
现在基本上是不用这种方法来提升效率的！(应该让编译器和 JVM 处理性能问题，只有在为了明确禁止覆写方法时才使用 final) <br>
在早期的 Java 实现中，如果将一个方法指明为 final，就是同意编译器把对该方法的调用转化为内嵌调用。当编译器遇到 final 方法的调用时，就会很小心地跳过普通的插入代码以执行方法的调用机制（将参数压栈，跳至方法代码处执行，然后跳回并清理栈中的参数，最终处理返回值），而用方法体内实际代码的副本替代方法调用。这消除了方法调用的开销。但是如果一个方法很大代码膨胀，你也许就看不到内嵌带来的性能提升，因为内嵌调用带来的性能提高被花费在方法里的时间抵消了。<br>
在最近的 Java 版本中，虚拟机可以探测到这些情况（尤其是 hotspot 技术），并优化去掉这些效率反而降低的内嵌调用方法。有很长一段时间，使用 final 来提高效率都被阻止。你**应该让编译器和 JVM 处理性能问题，只有在为了明确禁止覆写方法时才使用 final**。


> final 和 private 有什么区别？

类中所有的 private 方法都隐式地指定为 final。

1. final：可以访问，但不可覆写
2. private：不能访问，也就不可覆写。（可以给 private 方法添加 final 修饰，但是并不能给方法带来额外的含义。）

final 给的权限要更大一些（相比与 private，final 最起码可以访问）。

> 当覆盖、在子类中重写 private （隐式是 final 的）方法时，看上去奏效，而且编译器不会给出错误信息，这是指出 private 方法可以重写吗？

不，这只是一个假象！如果一个方法是 private 的，它就不是基类接口的一部分。它只是隐藏在类内部的代码，且恰好有相同的命名而已。

但是如果你在派生类中以相同的命名创建了 public，protected 或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，只是在创建新的方法而已。

由于 private 方法无法触及且能有效隐藏，除了把它看作类中的一部分，其他任何事物都不需要考虑到它。


> private final [方法|变量] 的异同

修饰方法时，private final 就等同于 private；而修饰变量则不是这样！


#### final类
当说一个类是 final （final 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。

之外，由于 final 类禁止继承，也就禁止覆写。（可以在 final 类中的方法加上 final 修饰符，但这并不会有任何意义，final类和属性在编译器上没有什么限制）

“覆写”关系是建立在“继承”之上的！

由于 final 类禁止继承，类中所有的方法都被隐式地指定为 final，所以没有办法覆写它们。可以在 final 类中的方法加上 final 修饰符，但不会增加任何意义。

1. final 类的字段并不会被隐式地指定为 final
2. final 类的方法隐式指定为 fianl



